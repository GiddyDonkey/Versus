<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VERSUS Test Suite</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Monaco', 'Menlo', monospace;
            background: #0a0a0a;
            color: #00ff00;
            padding: 20px;
            min-height: 100vh;
        }
        .header {
            text-align: center;
            padding: 20px;
            border-bottom: 1px solid #333;
            margin-bottom: 20px;
        }
        .header h1 {
            font-size: 24px;
            margin-bottom: 8px;
        }
        .header p {
            color: #666;
            font-size: 12px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        button {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #00ff00;
            padding: 10px 20px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
        }
        button:hover {
            background: #2a2a2a;
            border-color: #00ff00;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        button.danger {
            color: #ff4444;
            border-color: #ff4444;
        }
        button.danger:hover {
            background: #2a1a1a;
        }
        .log {
            background: #0d0d0d;
            border: 1px solid #222;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.6;
        }
        .log-entry {
            margin-bottom: 4px;
        }
        .log-entry.pass { color: #00ff00; }
        .log-entry.fail { color: #ff4444; }
        .log-entry.info { color: #00aaff; }
        .log-entry.warn { color: #ffaa00; }
        .log-entry.section {
            color: #ffffff;
            font-weight: bold;
            margin-top: 16px;
            margin-bottom: 8px;
            border-bottom: 1px solid #333;
            padding-bottom: 4px;
        }
        .summary {
            margin-top: 20px;
            padding: 20px;
            background: #1a1a1a;
            border: 1px solid #333;
        }
        .summary h3 {
            margin-bottom: 10px;
        }
        .stat {
            display: inline-block;
            margin-right: 20px;
            padding: 10px 15px;
            background: #0d0d0d;
            border-radius: 4px;
        }
        .stat.pass { border-left: 3px solid #00ff00; }
        .stat.fail { border-left: 3px solid #ff4444; }
        .stat.skip { border-left: 3px solid #ffaa00; }
        .state-panel {
            margin-top: 20px;
            padding: 15px;
            background: #1a1a1a;
            border: 1px solid #333;
            font-size: 11px;
        }
        .state-panel h4 {
            margin-bottom: 10px;
            color: #888;
        }
        .state-item {
            margin-bottom: 4px;
            color: #666;
        }
        .state-item span {
            color: #00aaff;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üß™ VERSUS Test Suite</h1>
        <p>Automated testing against Supabase backend</p>
    </div>

    <div class="controls">
        <button onclick="runAllTests()">‚ñ∂Ô∏è Run All Tests</button>
        <button onclick="runQuickTest()">‚ö° Quick Test (Core Flow)</button>
        <button onclick="testVotingOnly()">üó≥Ô∏è Test Voting Only</button>
        <button onclick="testNotifications()">üîî Test Notifications</button>
        <button class="danger" onclick="cleanupTestData()">üóëÔ∏è Cleanup Test Data</button>
        <button onclick="clearLog()">üìã Clear Log</button>
    </div>

    <div class="log" id="log"></div>

    <div class="summary" id="summary" style="display: none;">
        <h3>üìä Test Summary</h3>
        <div id="summaryStats"></div>
    </div>

    <div class="state-panel">
        <h4>Current Test State</h4>
        <div id="stateDisplay">No tests run yet</div>
    </div>

    <script>
        // ============================================
        // SUPABASE CONFIG
        // ============================================
        const SUPABASE_URL = 'https://kxwwnqqwelgnrtjtkufl.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt4d3ducXF3ZWxnbnJ0anRrdWZsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk4NTgwMTksImV4cCI6MjA4NTQzNDAxOX0.H03Qhf4hymkMpuIEnOwpuMHLie8oNaJNRbm4r72iSFM';
        
        const db = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // ============================================
        // TEST STATE
        // ============================================
        let testState = {
            squad: null,
            userA: null,
            userB: null,
            userC: null,
            challenge: null,
            testPrefix: 'TEST_' + Date.now()
        };

        let results = {
            passed: 0,
            failed: 0,
            skipped: 0,
            tests: []
        };

        // ============================================
        // LOGGING
        // ============================================
        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            const prefix = {
                'pass': '‚úÖ',
                'fail': '‚ùå',
                'info': '‚ÑπÔ∏è',
                'warn': '‚ö†Ô∏è',
                'section': '‚îÅ‚îÅ‚îÅ'
            }[type] || '';
            
            entry.textContent = `[${timestamp}] ${prefix} ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function logSection(title) {
            log(title, 'section');
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
            results = { passed: 0, failed: 0, skipped: 0, tests: [] };
            document.getElementById('summary').style.display = 'none';
        }

        function updateStateDisplay() {
            const stateEl = document.getElementById('stateDisplay');
            stateEl.innerHTML = `
                <div class="state-item">Squad: <span>${testState.squad?.name || 'None'}</span> (${testState.squad?.code || '-'})</div>
                <div class="state-item">User A: <span>${testState.userA?.name || 'None'}</span> (${testState.userA?.id?.slice(0,8) || '-'})</div>
                <div class="state-item">User B: <span>${testState.userB?.name || 'None'}</span> (${testState.userB?.id?.slice(0,8) || '-'})</div>
                <div class="state-item">User C: <span>${testState.userC?.name || 'None'}</span> (${testState.userC?.id?.slice(0,8) || '-'})</div>
                <div class="state-item">Challenge: <span>${testState.challenge?.challenge_type || 'None'}</span> (${testState.challenge?.status || '-'})</div>
            `;
        }

        function showSummary() {
            const summaryEl = document.getElementById('summary');
            const statsEl = document.getElementById('summaryStats');
            
            summaryEl.style.display = 'block';
            statsEl.innerHTML = `
                <span class="stat pass">Passed: ${results.passed}</span>
                <span class="stat fail">Failed: ${results.failed}</span>
                <span class="stat skip">Skipped: ${results.skipped}</span>
            `;
        }

        // ============================================
        // TEST HELPERS
        // ============================================
        async function test(name, fn) {
            try {
                log(`Testing: ${name}...`, 'info');
                await fn();
                log(`${name} - PASSED`, 'pass');
                results.passed++;
                results.tests.push({ name, status: 'pass' });
                return true;
            } catch (err) {
                log(`${name} - FAILED: ${err.message}`, 'fail');
                console.error(err);
                results.failed++;
                results.tests.push({ name, status: 'fail', error: err.message });
                return false;
            }
        }

        function assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        }

        function assertEqual(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(`${message || 'Assertion failed'}: expected ${expected}, got ${actual}`);
            }
        }

        async function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function generateCode() {
            return testState.testPrefix.slice(-6);
        }

        // ============================================
        // CORE TEST FUNCTIONS
        // ============================================
        
        async function createTestSquad() {
            const code = generateCode();
            const { data, error } = await db
                .from('squads')
                .insert({
                    code: code,
                    name: `Test Squad ${code}`
                })
                .select()
                .single();
            
            if (error) throw error;
            testState.squad = data;
            updateStateDisplay();
            return data;
        }

        async function createTestUser(name, avatar, isAdmin = false) {
            const { data, error } = await db
                .from('members')
                .insert({
                    squad_id: testState.squad.id,
                    user_key: `test_${name}_${Date.now()}`,
                    name: name,
                    avatar: avatar,
                    is_admin: isAdmin,
                    age: 25,
                    points: 0,
                    streak: 0
                })
                .select()
                .single();
            
            if (error) throw error;
            updateStateDisplay();
            return data;
        }

        async function createTestChallenge(challengerId, opponentId, type = 'photo') {
            const { data, error } = await db
                .from('challenges')
                .insert({
                    squad_id: testState.squad.id,
                    challenge_type: 'Test Challenge',
                    challenge_desc: 'Automated test challenge',
                    challenge_time: '30s',
                    challenger_id: challengerId,
                    opponent_id: opponentId,
                    challenger_media_url: 'https://via.placeholder.com/300',
                    challenger_media_type: type,
                    status: 'waiting'
                })
                .select()
                .single();
            
            if (error) throw error;
            testState.challenge = data;
            updateStateDisplay();
            return data;
        }

        async function respondToChallenge(challengeId) {
            const { data, error } = await db
                .from('challenges')
                .update({
                    opponent_media_url: 'https://via.placeholder.com/300/ff0000',
                    opponent_media_type: 'photo',
                    status: 'ready'
                })
                .eq('id', challengeId)
                .select()
                .single();
            
            if (error) throw error;
            testState.challenge = data;
            updateStateDisplay();
            return data;
        }

        async function openVoting(challengeId) {
            const { data, error } = await db
                .from('challenges')
                .update({
                    status: 'voting',
                    voting_ends_at: new Date(Date.now() + 3600000).toISOString()
                })
                .eq('id', challengeId)
                .select()
                .single();
            
            if (error) throw error;
            testState.challenge = data;
            updateStateDisplay();
            return data;
        }

        async function castVote(challengeId, voterId, voteForId) {
            // Insert vote
            const { error: voteError } = await db
                .from('votes')
                .insert({
                    challenge_id: challengeId,
                    voter_id: voterId,
                    vote_for: voteForId
                });
            
            if (voteError) throw voteError;
            
            // Get current challenge
            const { data: challenge } = await db
                .from('challenges')
                .select('*')
                .eq('id', challengeId)
                .single();
            
            // Update vote count
            const isForChallenger = voteForId === challenge.challenger_id;
            const { data, error } = await db
                .from('challenges')
                .update({
                    votes_for_challenger: (challenge.votes_for_challenger || 0) + (isForChallenger ? 1 : 0),
                    votes_for_opponent: (challenge.votes_for_opponent || 0) + (isForChallenger ? 0 : 1)
                })
                .eq('id', challengeId)
                .select()
                .single();
            
            if (error) throw error;
            testState.challenge = data;
            updateStateDisplay();
            return data;
        }

        async function completeChallenge(challengeId, winnerId) {
            const { data: challenge } = await db
                .from('challenges')
                .select('*')
                .eq('id', challengeId)
                .single();
            
            const { data, error } = await db
                .from('challenges')
                .update({
                    status: 'completed',
                    winner_id: winnerId,
                    completed_at: new Date().toISOString()
                })
                .eq('id', challengeId)
                .select()
                .single();
            
            if (error) throw error;
            
            // Update winner points
            const { data: winner } = await db
                .from('members')
                .select('points')
                .eq('id', winnerId)
                .single();
            
            await db
                .from('members')
                .update({ points: (winner?.points || 0) + 10 })
                .eq('id', winnerId);
            
            testState.challenge = data;
            updateStateDisplay();
            return data;
        }

        async function getChallenge(challengeId) {
            const { data, error } = await db
                .from('challenges')
                .select('*')
                .eq('id', challengeId)
                .single();
            
            if (error) throw error;
            return data;
        }

        async function getMember(memberId) {
            const { data, error } = await db
                .from('members')
                .select('*')
                .eq('id', memberId)
                .single();
            
            if (error) throw error;
            return data;
        }

        async function getVotes(challengeId) {
            const { data, error } = await db
                .from('votes')
                .select('*')
                .eq('challenge_id', challengeId);
            
            if (error) throw error;
            return data || [];
        }

        // ============================================
        // TEST SUITES
        // ============================================

        async function runAllTests() {
            clearLog();
            log('Starting VERSUS Full Test Suite...', 'info');
            log(`Test prefix: ${testState.testPrefix}`, 'info');
            
            // Setup
            logSection('SETUP: Creating Test Environment');
            
            await test('Create Squad', async () => {
                await createTestSquad();
                assert(testState.squad, 'Squad should be created');
                assert(testState.squad.code, 'Squad should have a code');
            });

            await test('Create User A (Admin)', async () => {
                testState.userA = await createTestUser('TestUserA', 'üë®', true);
                assert(testState.userA, 'User A should be created');
                assertEqual(testState.userA.is_admin, true, 'User A should be admin');
            });

            await test('Create User B', async () => {
                testState.userB = await createTestUser('TestUserB', 'üë©', false);
                assert(testState.userB, 'User B should be created');
            });

            await test('Create User C (for 3-person voting)', async () => {
                testState.userC = await createTestUser('TestUserC', 'üßë', false);
                assert(testState.userC, 'User C should be created');
            });

            // Challenge Flow
            logSection('TEST: Challenge Creation Flow');

            await test('Create Challenge (A challenges B)', async () => {
                await createTestChallenge(testState.userA.id, testState.userB.id);
                assert(testState.challenge, 'Challenge should be created');
                assertEqual(testState.challenge.status, 'waiting', 'Status should be waiting');
            });

            await test('Respond to Challenge (B submits)', async () => {
                await respondToChallenge(testState.challenge.id);
                assertEqual(testState.challenge.status, 'ready', 'Status should be ready');
                assert(testState.challenge.opponent_media_url, 'Should have opponent media');
            });

            // 2-Person Voting (A and B both vote)
            logSection('TEST: 2-Person Voting Flow');

            await test('Open Voting', async () => {
                await openVoting(testState.challenge.id);
                assertEqual(testState.challenge.status, 'voting', 'Status should be voting');
            });

            await test('User A casts vote (for self)', async () => {
                await castVote(testState.challenge.id, testState.userA.id, testState.userA.id);
                const votes = await getVotes(testState.challenge.id);
                assertEqual(votes.length, 1, 'Should have 1 vote');
            });

            await test('User B casts vote (for self - creates tie)', async () => {
                await castVote(testState.challenge.id, testState.userB.id, testState.userB.id);
                const votes = await getVotes(testState.challenge.id);
                assertEqual(votes.length, 2, 'Should have 2 votes');
                
                const challenge = await getChallenge(testState.challenge.id);
                assertEqual(challenge.votes_for_challenger, 1, 'Challenger should have 1 vote');
                assertEqual(challenge.votes_for_opponent, 1, 'Opponent should have 1 vote');
            });

            await test('Complete challenge with winner (AI tiebreaker)', async () => {
                // In tie, pick random winner (we'll pick A)
                await completeChallenge(testState.challenge.id, testState.userA.id);
                const challenge = await getChallenge(testState.challenge.id);
                assertEqual(challenge.status, 'completed', 'Status should be completed');
                assertEqual(challenge.winner_id, testState.userA.id, 'Winner should be User A');
            });

            await test('Winner points updated', async () => {
                const userA = await getMember(testState.userA.id);
                assertEqual(userA.points, 10, 'User A should have 10 points');
            });

            // 3-Person Voting Test
            logSection('TEST: 3-Person Voting Flow');

            await test('Create second challenge (B challenges A)', async () => {
                const { data, error } = await db
                    .from('challenges')
                    .insert({
                        squad_id: testState.squad.id,
                        challenge_type: 'Test Challenge 2',
                        challenge_desc: '3-person voting test',
                        challenge_time: '30s',
                        challenger_id: testState.userB.id,
                        opponent_id: testState.userA.id,
                        challenger_media_url: 'https://via.placeholder.com/300/00ff00',
                        challenger_media_type: 'photo',
                        status: 'waiting'
                    })
                    .select()
                    .single();
                
                if (error) throw error;
                testState.challenge = data;
                assert(testState.challenge, 'Second challenge should be created');
            });

            await test('User A responds', async () => {
                await respondToChallenge(testState.challenge.id);
                assertEqual(testState.challenge.status, 'ready', 'Status should be ready');
            });

            await test('Open voting for 3-person', async () => {
                await openVoting(testState.challenge.id);
                assertEqual(testState.challenge.status, 'voting', 'Status should be voting');
            });

            await test('User C votes (non-participant)', async () => {
                await castVote(testState.challenge.id, testState.userC.id, testState.userB.id);
                const votes = await getVotes(testState.challenge.id);
                assertEqual(votes.length, 1, 'Should have 1 vote from non-participant');
            });

            await test('Complete with C\'s vote determining winner', async () => {
                await completeChallenge(testState.challenge.id, testState.userB.id);
                const challenge = await getChallenge(testState.challenge.id);
                assertEqual(challenge.winner_id, testState.userB.id, 'User B should win');
            });

            await test('User B points updated', async () => {
                const userB = await getMember(testState.userB.id);
                assertEqual(userB.points, 10, 'User B should have 10 points');
            });

            // Edge Cases
            logSection('TEST: Edge Cases');

            await test('Cannot vote twice', async () => {
                try {
                    await castVote(testState.challenge.id, testState.userC.id, testState.userA.id);
                    throw new Error('Should have failed - duplicate vote');
                } catch (err) {
                    assert(err.message.includes('duplicate') || err.code === '23505', 'Should be duplicate error');
                }
            });

            await test('Cannot complete already completed challenge', async () => {
                const { data, error } = await db
                    .from('challenges')
                    .update({ status: 'completed' })
                    .eq('id', testState.challenge.id)
                    .eq('status', 'voting') // This should fail
                    .select()
                    .single();
                
                // Should return null since status isn't 'voting'
                assert(!data || data.status === 'completed', 'Should not re-complete');
            });

            // Data Integrity
            logSection('TEST: Data Integrity');

            await test('All test data exists', async () => {
                const { data: squad } = await db.from('squads').select('*').eq('id', testState.squad.id).single();
                assert(squad, 'Squad should exist');
                
                const { data: members } = await db.from('members').select('*').eq('squad_id', testState.squad.id);
                assertEqual(members.length, 3, 'Should have 3 members');
                
                const { data: challenges } = await db.from('challenges').select('*').eq('squad_id', testState.squad.id);
                assertEqual(challenges.length, 2, 'Should have 2 challenges');
            });

            // Summary
            logSection('TEST COMPLETE');
            log(`Passed: ${results.passed}, Failed: ${results.failed}`, results.failed > 0 ? 'fail' : 'pass');
            showSummary();
        }

        async function runQuickTest() {
            clearLog();
            log('Running Quick Test (Core Flow)...', 'info');
            
            await test('Create Squad', async () => {
                await createTestSquad();
                assert(testState.squad, 'Squad created');
            });

            await test('Create 2 Users', async () => {
                testState.userA = await createTestUser('QuickA', 'üë®', true);
                testState.userB = await createTestUser('QuickB', 'üë©', false);
                assert(testState.userA && testState.userB, 'Users created');
            });

            await test('Challenge Flow', async () => {
                await createTestChallenge(testState.userA.id, testState.userB.id);
                await respondToChallenge(testState.challenge.id);
                await openVoting(testState.challenge.id);
                await castVote(testState.challenge.id, testState.userA.id, testState.userB.id);
                await castVote(testState.challenge.id, testState.userB.id, testState.userB.id);
                await completeChallenge(testState.challenge.id, testState.userB.id);
                
                const challenge = await getChallenge(testState.challenge.id);
                assertEqual(challenge.status, 'completed', 'Challenge completed');
            });

            logSection('QUICK TEST COMPLETE');
            showSummary();
        }

        async function testVotingOnly() {
            clearLog();
            log('Testing Voting System Only...', 'info');
            
            // First check if we have existing test data
            if (!testState.squad) {
                log('No test squad found. Creating one...', 'warn');
                await createTestSquad();
                testState.userA = await createTestUser('VoteTestA', 'üë®', true);
                testState.userB = await createTestUser('VoteTestB', 'üë©', false);
            }

            await test('Create challenge for voting test', async () => {
                await createTestChallenge(testState.userA.id, testState.userB.id);
                await respondToChallenge(testState.challenge.id);
                assert(testState.challenge.status === 'ready', 'Challenge ready');
            });

            await test('Transition to voting status', async () => {
                await openVoting(testState.challenge.id);
                assertEqual(testState.challenge.status, 'voting', 'Status is voting');
            });

            await test('Both participants can vote', async () => {
                await castVote(testState.challenge.id, testState.userA.id, testState.userA.id);
                await castVote(testState.challenge.id, testState.userB.id, testState.userA.id);
                
                const challenge = await getChallenge(testState.challenge.id);
                assertEqual(challenge.votes_for_challenger, 2, 'Both voted for challenger');
            });

            await test('Winner determined correctly', async () => {
                await completeChallenge(testState.challenge.id, testState.userA.id);
                const challenge = await getChallenge(testState.challenge.id);
                assertEqual(challenge.winner_id, testState.userA.id, 'Correct winner');
            });

            showSummary();
        }

        async function testNotifications() {
            clearLog();
            log('Testing Notification Triggers...', 'info');
            log('(Check browser console and main app for notifications)', 'warn');
            
            if (!testState.squad) {
                await createTestSquad();
                testState.userA = await createTestUser('NotifyTestA', 'üë®', true);
            }

            await test('Add new member (should trigger notification)', async () => {
                log('Adding new member - watch for notification in main app...', 'info');
                testState.userB = await createTestUser('NewMember_' + Date.now(), 'üÜï', false);
                await sleep(1000);
                log('Member added. Check if notification appeared in main app.', 'info');
            });

            await test('Create challenge (should notify opponent)', async () => {
                log('Creating challenge - opponent should be notified...', 'info');
                await createTestChallenge(testState.userA.id, testState.userB.id);
                await sleep(1000);
                log('Challenge created. Check if User B got notification.', 'info');
            });

            showSummary();
        }

        async function cleanupTestData() {
            if (!confirm('Delete ALL test data from this session?')) return;
            
            clearLog();
            log('Cleaning up test data...', 'warn');

            try {
                // Delete in order: votes -> challenges -> members -> squads
                if (testState.squad) {
                    // Delete votes for challenges in this squad
                    const { data: challenges } = await db
                        .from('challenges')
                        .select('id')
                        .eq('squad_id', testState.squad.id);
                    
                    if (challenges) {
                        for (const c of challenges) {
                            await db.from('votes').delete().eq('challenge_id', c.id);
                        }
                    }
                    
                    // Delete challenges
                    await db.from('challenges').delete().eq('squad_id', testState.squad.id);
                    log('Deleted challenges', 'info');
                    
                    // Delete members
                    await db.from('members').delete().eq('squad_id', testState.squad.id);
                    log('Deleted members', 'info');
                    
                    // Delete squad
                    await db.from('squads').delete().eq('id', testState.squad.id);
                    log('Deleted squad', 'info');
                }

                // Reset state
                testState = {
                    squad: null,
                    userA: null,
                    userB: null,
                    userC: null,
                    challenge: null,
                    testPrefix: 'TEST_' + Date.now()
                };
                updateStateDisplay();
                
                log('Cleanup complete!', 'pass');
            } catch (err) {
                log('Cleanup error: ' + err.message, 'fail');
            }
        }

        // Initialize
        log('Test suite ready. Click "Run All Tests" to begin.', 'info');
        updateStateDisplay();
    </script>
</body>
</html>
